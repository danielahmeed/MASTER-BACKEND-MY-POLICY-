<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ingestion Module - Code Explained (Detailed)</title>

<style>
body { font-family: Arial, Helvetica, sans-serif; font-size: 11pt; line-height: 1.5; color: #333; margin: 2em; }
h1 { color: #1a365d; font-size: 22pt; border-bottom: 2px solid #3182ce; padding-bottom: 0.3em; margin-top: 1.5em; }
h2 { color: #2c5282; font-size: 16pt; margin-top: 1.2em; }
h3 { color: #2d3748; font-size: 13pt; margin-top: 1em; }
p { margin: 0.6em 0; text-align: justify; }
pre, code { background: #f7fafc; border: 1px solid #e2e8f0; padding: 0.2em 0.4em; font-family: Consolas, monospace; font-size: 9pt; }
pre { padding: 0.8em; overflow-x: auto; white-space: pre-wrap; }
code { display: inline; }
ul, ol { margin: 0.5em 0; padding-left: 1.5em; }
li { margin: 0.3em 0; }
hr { border: none; border-top: 1px solid #cbd5e0; margin: 1.5em 0; }
strong { color: #1a365d; }
blockquote { border-left: 4px solid #3182ce; margin: 1em 0; padding-left: 1em; color: #4a5568; }
a { color: #3182ce; text-decoration: none; }
table { border-collapse: collapse; width: 100%; margin: 1em 0; }
th, td { border: 1px solid #e2e8f0; padding: 0.5em; text-align: left; }
th { background: #edf2f7; font-weight: bold; }
@page { size: A4; margin: 2cm; }
</style>

</head>
<body>
<h1 id="ingestion-module-complete-line-by-line-code-explanation">Ingestion Module – Complete Line-by-Line Code Explanation</h1>
<p><strong>Data Pipeline Service – Ingestion Package</strong><br />
<strong>Document Version:</strong> 2.0<br />
<strong>Purpose:</strong> Every line of code explained in detail.</p>
<hr />
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li><a href="#1-uploadresponsejava">UploadResponse.java</a></li>
<li><a href="#2-jobstatusresponsejava">JobStatusResponse.java</a></li>
<li><a href="#3-progressupdaterequestjava">ProgressUpdateRequest.java</a></li>
<li><a href="#4-statusupdaterequestjava">StatusUpdateRequest.java</a></li>
<li><a href="#5-ingestionstatusjava">IngestionStatus.java</a></li>
<li><a href="#6-ingestionjobjava">IngestionJob.java</a></li>
<li><a href="#7-ingestionjobrepositoryjava">IngestionJobRepository.java</a></li>
<li><a href="#8-ingestioncontrollerjava">IngestionController.java</a></li>
<li><a href="#9-publicingestioncontrollerjava">PublicIngestionController.java</a></li>
<li><a href="#10-ingestionservicejava">IngestionService.java</a></li>
</ol>
<hr />
<h2 id="1-uploadresponsejava">1. UploadResponse.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.dto;
     2
     3  import com.mypolicy.pipeline.ingestion.model.IngestionStatus;
     4
     5  /**
     6  * Response after successful file upload.
     7  */
     8  public class UploadResponse {
     9    private String jobId;
    10    private IngestionStatus status;
    11
    12    public UploadResponse() {
    13    }
    14
    15    public UploadResponse(String jobId, IngestionStatus status) {
    16      this.jobId = jobId;
    17      this.status = status;
    18    }
    19
    20    public String getJobId() { return jobId; }
    21    public void setJobId(String jobId) { this.jobId = jobId; }
    22    public IngestionStatus getStatus() { return status; }
    23    public void setStatus(IngestionStatus status) { this.status = status; }
    24  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.dto;</code></td>
<td>Declares that this class belongs to the Data Transfer Object package for the ingestion module.</td>
</tr>
<tr>
<td>2</td>
<td><em>(blank)</em></td>
<td>Blank line for readability.</td>
</tr>
<tr>
<td>3</td>
<td><code>import com.mypolicy.pipeline.ingestion.model.IngestionStatus;</code></td>
<td>Imports the IngestionStatus enum so we can use it as a field type.</td>
</tr>
<tr>
<td>4</td>
<td><em>(blank)</em></td>
<td>Blank line.</td>
</tr>
<tr>
<td>5-7</td>
<td><code>/** ... */</code></td>
<td>Javadoc comment: describes that this class is the response returned after a successful file upload.</td>
</tr>
<tr>
<td>8</td>
<td><code>public class UploadResponse {</code></td>
<td>Starts the class definition. Public means it can be used by other packages.</td>
</tr>
<tr>
<td>9</td>
<td><code>private String jobId;</code></td>
<td>Private field: stores the unique job identifier (e.g. UUID string) returned to the client.</td>
</tr>
<tr>
<td>10</td>
<td><code>private IngestionStatus status;</code></td>
<td>Private field: stores the initial status (UPLOADED) after upload.</td>
</tr>
<tr>
<td>11</td>
<td><em>(blank)</em></td>
<td>Blank line.</td>
</tr>
<tr>
<td>12-13</td>
<td><code>public UploadResponse() { }</code></td>
<td>No-argument constructor. Used by JSON libraries when deserializing; creates an empty object.</td>
</tr>
<tr>
<td>14</td>
<td><em>(blank)</em></td>
<td>Blank line.</td>
</tr>
<tr>
<td>15</td>
<td><code>public UploadResponse(String jobId, IngestionStatus status) {</code></td>
<td>Constructor that accepts both field values.</td>
</tr>
<tr>
<td>16</td>
<td><code>this.jobId = jobId;</code></td>
<td>Assigns the jobId parameter to the instance field. <code>this.</code> refers to the object being constructed.</td>
</tr>
<tr>
<td>17</td>
<td><code>this.status = status;</code></td>
<td>Assigns the status parameter to the instance field.</td>
</tr>
<tr>
<td>18</td>
<td><code>}</code></td>
<td>Closes the constructor.</td>
</tr>
<tr>
<td>19</td>
<td><em>(blank)</em></td>
<td>Blank line.</td>
</tr>
<tr>
<td>20</td>
<td><code>public String getJobId() { return jobId; }</code></td>
<td>Getter for jobId. Returns the current value of the jobId field.</td>
</tr>
<tr>
<td>21</td>
<td><code>public void setJobId(String jobId) { this.jobId = jobId; }</code></td>
<td>Setter for jobId. Updates the jobId field with the new value.</td>
</tr>
<tr>
<td>22</td>
<td><code>public IngestionStatus getStatus() { return status; }</code></td>
<td>Getter for status. Returns the current status.</td>
</tr>
<tr>
<td>23</td>
<td><code>public void setStatus(IngestionStatus status) { this.status = status; }</code></td>
<td>Setter for status. Updates the status field.</td>
</tr>
<tr>
<td>24</td>
<td><code>}</code></td>
<td>Closes the class.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2-jobstatusresponsejava">2. JobStatusResponse.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.dto;
     2
     3  import com.mypolicy.pipeline.ingestion.model.IngestionStatus;
     4
     5  import java.time.LocalDateTime;
     6
     7  /**
     8  * Job status response for BFF/Processing Service.
     9  */
    10  public class JobStatusResponse {
    11    private String jobId;
    12    private IngestionStatus status;
    13    private int processedRecords;
    14    private int totalRecords;
    15    private String filePath;
    16    private String insurerId;
    17    private String fileType;
    18    private LocalDateTime createdAt;
    19    private LocalDateTime updatedAt;
    20
    21    public JobStatusResponse() {
    22    }
    23
    24    public JobStatusResponse(String jobId, IngestionStatus status, int processedRecords,
    25        int totalRecords, String filePath, String insurerId, String fileType,
    26        LocalDateTime createdAt, LocalDateTime updatedAt) {
    27    this.jobId = jobId;
    28    this.status = status;
    29    this.processedRecords = processedRecords;
    30    this.totalRecords = totalRecords;
    31    this.filePath = filePath;
    32    this.insurerId = insurerId;
    33    this.fileType = fileType;
    34    this.createdAt = createdAt;
    35    this.updatedAt = updatedAt;
    36    }
    37
    38    public String getJobId() { return jobId; }
    39    public void setJobId(String jobId) { this.jobId = jobId; }
    40    public IngestionStatus getStatus() { return status; }
    41    public void setStatus(IngestionStatus status) { this.status = status; }
    42    public int getProcessedRecords() { return processedRecords; }
    43    public void setProcessedRecords(int processedRecords) { this.processedRecords = processedRecords; }
    44    public int getTotalRecords() { return totalRecords; }
    45    public void setTotalRecords(int totalRecords) { this.totalRecords = totalRecords; }
    46    public String getFilePath() { return filePath; }
    47    public void setFilePath(String filePath) { this.filePath = filePath; }
    48    public String getInsurerId() { return insurerId; }
    49    public void setInsurerId(String insurerId) { this.insurerId = insurerId; }
    50    public String getFileType() { return fileType; }
    51    public void setFileType(String fileType) { this.fileType = fileType; }
    52    public LocalDateTime getCreatedAt() { return createdAt; }
    53    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    54    public LocalDateTime getUpdatedAt() { return updatedAt; }
    55    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    56  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.dto;</code></td>
<td>Package declaration for DTO classes.</td>
</tr>
<tr>
<td>3</td>
<td><code>import com.mypolicy.pipeline.ingestion.model.IngestionStatus;</code></td>
<td>Import for the status enum.</td>
</tr>
<tr>
<td>5</td>
<td><code>import java.time.LocalDateTime;</code></td>
<td>Import for date/time without timezone; used for createdAt and updatedAt.</td>
</tr>
<tr>
<td>7-9</td>
<td><code>/** Job status response... */</code></td>
<td>Javadoc: this DTO is used by BFF and Processing Service to return full job details.</td>
</tr>
<tr>
<td>10</td>
<td><code>public class JobStatusResponse {</code></td>
<td>Class definition.</td>
</tr>
<tr>
<td>11</td>
<td><code>private String jobId;</code></td>
<td>Unique job identifier.</td>
</tr>
<tr>
<td>12</td>
<td><code>private IngestionStatus status;</code></td>
<td>Current lifecycle state (UPLOADED, PROCESSING, COMPLETED, FAILED).</td>
</tr>
<tr>
<td>13</td>
<td><code>private int processedRecords;</code></td>
<td>Number of records processed so far.</td>
</tr>
<tr>
<td>14</td>
<td><code>private int totalRecords;</code></td>
<td>Total records in the file (for progress calculation).</td>
</tr>
<tr>
<td>15</td>
<td><code>private String filePath;</code></td>
<td>Absolute path where the file is stored on disk.</td>
</tr>
<tr>
<td>16</td>
<td><code>private String insurerId;</code></td>
<td>Insurer ID this job belongs to.</td>
</tr>
<tr>
<td>17</td>
<td><code>private String fileType;</code></td>
<td>"normal" or "correction".</td>
</tr>
<tr>
<td>18</td>
<td><code>private LocalDateTime createdAt;</code></td>
<td>When the job was created.</td>
</tr>
<tr>
<td>19</td>
<td><code>private LocalDateTime updatedAt;</code></td>
<td>When the job was last updated.</td>
</tr>
<tr>
<td>21-22</td>
<td><code>public JobStatusResponse() { }</code></td>
<td>No-arg constructor for deserialization.</td>
</tr>
<tr>
<td>24-26</td>
<td><code>public JobStatusResponse(...)</code></td>
<td>Full constructor with all 9 parameters.</td>
</tr>
<tr>
<td>27-35</td>
<td><code>this.jobId = jobId;</code> etc.</td>
<td>Assigns each parameter to the corresponding field.</td>
</tr>
<tr>
<td>38-55</td>
<td>Getters and setters</td>
<td>Standard JavaBean accessors for all fields; used for JSON serialization and reading/writing.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3-progressupdaterequestjava">3. ProgressUpdateRequest.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.dto;
     2
     3  /**
     4  * Internal request for incrementing processed records.
     5  * Idempotent when retried with same delta.
     6  */
     7  public class ProgressUpdateRequest {
     8    private int processedRecordsDelta;
     9
    10    public int getProcessedRecordsDelta() { return processedRecordsDelta; }
    11    public void setProcessedRecordsDelta(int processedRecordsDelta) {
    12      this.processedRecordsDelta = processedRecordsDelta;
    13    }
    14  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.dto;</code></td>
<td>Package declaration.</td>
</tr>
<tr>
<td>3-6</td>
<td><code>/** Internal request... */</code></td>
<td>Javadoc: used internally when Processing sends progress updates. Idempotent means repeating the same request has the same effect.</td>
</tr>
<tr>
<td>7</td>
<td><code>public class ProgressUpdateRequest {</code></td>
<td>Class definition.</td>
</tr>
<tr>
<td>8</td>
<td><code>private int processedRecordsDelta;</code></td>
<td>Holds how many more records were processed (e.g. 100). Added to the job's processedRecords.</td>
</tr>
<tr>
<td>10</td>
<td><code>public int getProcessedRecordsDelta() { return processedRecordsDelta; }</code></td>
<td>Getter.</td>
</tr>
<tr>
<td>11-13</td>
<td><code>public void setProcessedRecordsDelta(...)</code></td>
<td>Setter. The JSON body <code>{"processedRecordsDelta": 50}</code> maps to this.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-statusupdaterequestjava">4. StatusUpdateRequest.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.dto;
     2
     3  import com.mypolicy.pipeline.ingestion.model.IngestionStatus;
     4
     5  /**
     6  * Internal request for job status transition.
     7  * Enforces state machine: UPLOADED → PROCESSING → COMPLETED | FAILED
     8  */
     9  public class StatusUpdateRequest {
    10    private IngestionStatus status;
    11    private String failureReason;
    12
    13    public IngestionStatus getStatus() { return status; }
    14    public void setStatus(IngestionStatus status) { this.status = status; }
    15    public String getFailureReason() { return failureReason; }
    16    public void setFailureReason(String failureReason) { this.failureReason = failureReason; }
    17  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.dto;</code></td>
<td>Package declaration.</td>
</tr>
<tr>
<td>3</td>
<td><code>import com.mypolicy.pipeline.ingestion.model.IngestionStatus;</code></td>
<td>Import for status enum.</td>
</tr>
<tr>
<td>5-8</td>
<td>Javadoc</td>
<td>Describes that this request changes job status according to the state machine.</td>
</tr>
<tr>
<td>9</td>
<td><code>public class StatusUpdateRequest {</code></td>
<td>Class definition.</td>
</tr>
<tr>
<td>10</td>
<td><code>private IngestionStatus status;</code></td>
<td>Target status (PROCESSING, COMPLETED, or FAILED).</td>
</tr>
<tr>
<td>11</td>
<td><code>private String failureReason;</code></td>
<td>Error message when status is FAILED; null otherwise.</td>
</tr>
<tr>
<td>13-16</td>
<td>Getters and setters</td>
<td>Accessors for both fields.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="5-ingestionstatusjava">5. IngestionStatus.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.model;
     2
     3  /**
     4  * Ingestion job lifecycle states.
     5  * State machine: UPLOADED → PROCESSING → COMPLETED | FAILED
     6  */
     7  public enum IngestionStatus {
     8    UPLOADED, PROCESSING, COMPLETED, FAILED
     9  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.model;</code></td>
<td>Package for domain models.</td>
</tr>
<tr>
<td>3-6</td>
<td>Javadoc</td>
<td>Describes the four allowed states and the flow.</td>
</tr>
<tr>
<td>7</td>
<td><code>public enum IngestionStatus {</code></td>
<td>Enum definition. Only these four values are valid.</td>
</tr>
<tr>
<td>8</td>
<td><code>UPLOADED, PROCESSING, COMPLETED, FAILED</code></td>
<td>UPLOADED = file stored; PROCESSING = being processed; COMPLETED = success; FAILED = error.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-ingestionjobjava">6. IngestionJob.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.model;
     2
     3  import org.springframework.data.annotation.Id;
     4  import org.springframework.data.mongodb.core.index.Indexed;
     5  import org.springframework.data.mongodb.core.mapping.Document;
     6
     7  import java.time.LocalDateTime;
     8
     9  /**
    10  * Ingestion job document - tracks file upload and processing lifecycle.
    11  * Stored in MongoDB for flexible schema and high write throughput.
    12  *
    13  * Consolidated Service: Part of data-pipeline-service.
    14  */
    15  @Document(collection = &quot;ingestion_jobs&quot;)
    16  public class IngestionJob {
    17
    18    @Id
    19    private String jobId;
    20
    21    private String insurerId;
    21    private String filePath;
    22
    23    @Indexed
    24    private IngestionStatus status;
    25    private int totalRecords;
    26    private int processedRecords;
    27    private String uploadedBy;
    28    private String failureReason;
    29
    30    @Indexed
    31    private LocalDateTime createdAt;
    32    private LocalDateTime updatedAt;
    33
    34    public IngestionJob() {
    35    }
    36
    37    public IngestionJob(String jobId, String insurerId, String filePath, IngestionStatus status,
    38        int totalRecords, int processedRecords, String uploadedBy, String failureReason,
    39        LocalDateTime createdAt, LocalDateTime updatedAt) {
    40    this.jobId = jobId;
    41    this.insurerId = insurerId;
    42    this.filePath = filePath;
    43    this.status = status;
    44    this.totalRecords = totalRecords;
    45    this.processedRecords = processedRecords;
    46    this.uploadedBy = uploadedBy;
    47    this.failureReason = failureReason;
    48    this.createdAt = createdAt;
    49    this.updatedAt = updatedAt;
    50    }
    51
    52    public String getJobId() { return jobId; }
    53    public void setJobId(String jobId) { this.jobId = jobId; }
    54    public String getInsurerId() { return insurerId; }
    55    public void setInsurerId(String insurerId) { this.insurerId = insurerId; }
    56    public String getFilePath() { return filePath; }
    57    public void setFilePath(String filePath) { this.filePath = filePath; }
    58    public IngestionStatus getStatus() { return status; }
    59    public void setStatus(IngestionStatus status) { this.status = status; }
    60    public int getTotalRecords() { return totalRecords; }
    61    public void setTotalRecords(int totalRecords) { this.totalRecords = totalRecords; }
    62    public int getProcessedRecords() { return processedRecords; }
    63    public void setProcessedRecords(int processedRecords) { this.processedRecords = processedRecords; }
    64    public String getUploadedBy() { return uploadedBy; }
    65    public void setUploadedBy(String uploadedBy) { this.uploadedBy = uploadedBy; }
    66    public String getFailureReason() { return failureReason; }
    67    public void setFailureReason(String failureReason) { this.failureReason = failureReason; }
    68    public LocalDateTime getCreatedAt() { return createdAt; }
    69    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    70    public LocalDateTime getUpdatedAt() { return updatedAt; }
    71    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
    72  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.model;</code></td>
<td>Model package.</td>
</tr>
<tr>
<td>3</td>
<td><code>import org.springframework.data.annotation.Id;</code></td>
<td>@Id marks the MongoDB document ID.</td>
</tr>
<tr>
<td>4</td>
<td><code>import org.springframework.data.mongodb.core.index.Indexed;</code></td>
<td>@Indexed creates an index for faster queries.</td>
</tr>
<tr>
<td>5</td>
<td><code>import org.springframework.data.mongodb.core.mapping.Document;</code></td>
<td>@Document maps this class to a MongoDB collection.</td>
</tr>
<tr>
<td>7</td>
<td><code>import java.time.LocalDateTime;</code></td>
<td>For timestamps.</td>
</tr>
<tr>
<td>15</td>
<td><code>@Document(collection = "ingestion_jobs")</code></td>
<td>MongoDB collection name.</td>
</tr>
<tr>
<td>18-19</td>
<td><code>@Id</code> <code>private String jobId;</code></td>
<td>jobId is the document's primary key.</td>
</tr>
<tr>
<td>20-21</td>
<td><code>private String insurerId;</code> <code>private String filePath;</code></td>
<td>Insurer ID and file storage path.</td>
</tr>
<tr>
<td>23-28</td>
<td><code>@Indexed status</code> and other fields</td>
<td>status is indexed for findByStatus; totalRecords, processedRecords, uploadedBy, failureReason.</td>
</tr>
<tr>
<td>30-32</td>
<td><code>@Indexed createdAt</code> <code>updatedAt</code></td>
<td>Timestamps; indexed for time-based queries.</td>
</tr>
<tr>
<td>34-35</td>
<td><code>public IngestionJob() { }</code></td>
<td>No-arg constructor for MongoDB deserialization.</td>
</tr>
<tr>
<td>37-50</td>
<td>Full constructor</td>
<td>Assigns all 10 fields.</td>
</tr>
<tr>
<td>52-71</td>
<td>Getters and setters</td>
<td>Standard accessors for all fields.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-ingestionjobrepositoryjava">7. IngestionJobRepository.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.repository;
     2
     3  import com.mypolicy.pipeline.ingestion.model.IngestionJob;
     4  import com.mypolicy.pipeline.ingestion.model.IngestionStatus;
     5  import org.springframework.data.mongodb.repository.MongoRepository;
     6  import org.springframework.stereotype.Repository;
     7
     8  import java.util.List;
     9
    10  /**
    11  * MongoDB repository for ingestion job tracking.
    12  *
    13  * Consolidated Service: Part of data-pipeline-service.
    14  */
    15  @Repository
    16  public interface IngestionJobRepository extends MongoRepository&lt;IngestionJob, String&gt; {
    17    List&lt;IngestionJob&gt; findByStatus(IngestionStatus status);
    18    List&lt;IngestionJob&gt; findByInsurerId(String insurerId);
    19  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.repository;</code></td>
<td>Repository package.</td>
</tr>
<tr>
<td>3-4</td>
<td>Imports</td>
<td>IngestionJob entity and IngestionStatus enum.</td>
</tr>
<tr>
<td>5</td>
<td><code>import org.springframework.data.mongodb.repository.MongoRepository;</code></td>
<td>Base interface for MongoDB CRUD.</td>
</tr>
<tr>
<td>6</td>
<td><code>import org.springframework.stereotype.Repository;</code></td>
<td>Marks this as a Spring repository bean.</td>
</tr>
<tr>
<td>8</td>
<td><code>import java.util.List;</code></td>
<td>For list return types.</td>
</tr>
<tr>
<td>15</td>
<td><code>@Repository</code></td>
<td>Spring creates a bean implementing this interface.</td>
</tr>
<tr>
<td>16</td>
<td><code>extends MongoRepository&lt;IngestionJob, String&gt;</code></td>
<td>Entity type = IngestionJob, ID type = String. Provides save, findById, delete, etc.</td>
</tr>
<tr>
<td>17</td>
<td><code>List&lt;IngestionJob&gt; findByStatus(IngestionStatus status);</code></td>
<td>Spring Data generates the query. Finds all jobs with the given status.</td>
</tr>
<tr>
<td>18</td>
<td><code>List&lt;IngestionJob&gt; findByInsurerId(String insurerId);</code></td>
<td>Finds all jobs for a given insurer.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-ingestioncontrollerjava">8. IngestionController.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.controller;
     2
     3  import com.mypolicy.pipeline.ingestion.dto.JobStatusResponse;
     4  import com.mypolicy.pipeline.ingestion.dto.ProgressUpdateRequest;
     5  import com.mypolicy.pipeline.ingestion.dto.StatusUpdateRequest;
     6  import com.mypolicy.pipeline.ingestion.dto.UploadResponse;
     7  import com.mypolicy.pipeline.ingestion.service.IngestionService;
     8  import jakarta.validation.Valid;
     9  import org.slf4j.Logger;
    10  import org.slf4j.LoggerFactory;
    11  import org.springframework.http.HttpStatus;
    12  import org.springframework.http.ResponseEntity;
    13  import org.springframework.web.bind.annotation.*;
    14  import org.springframework.web.multipart.MultipartFile;
    15
    16  import java.io.IOException;
    17
    18  /**
    19  * Ingestion API: file upload, status retrieval, progress/status updates.
    20  * JWT validation is done at BFF level for upload.
    21  *
    22  * Consolidated Service: Part of data-pipeline-service on port 8082.
    23  */
    24  @RestController
    25  @RequestMapping(&quot;/api/v1/ingestion&quot;)
    26  @RequiredArgsConstructor
    27  public class IngestionController {
    27
    28    private static final Logger log = LoggerFactory.getLogger(IngestionController.class);
    29    private final IngestionService ingestionService;
    30
    31    @PostMapping(&quot;/upload&quot;)
    32    public ResponseEntity&lt;UploadResponse&gt; uploadFile(
    32        @RequestParam(&quot;file&quot;) MultipartFile file,
    33        @RequestParam(&quot;insurerId&quot;) String insurerId,
    34        @RequestParam(&quot;uploadedBy&quot;) String uploadedBy,
    35        @RequestParam(value = &quot;fileType&quot;, required = false) String fileType) {
    36
    37    log.info(&quot;[Ingestion API] POST /upload - insurerId={}, uploadedBy={}&quot;, insurerId, uploadedBy);
    38
    39    try {
    40      UploadResponse response = ingestionService.uploadFile(file, insurerId, uploadedBy, fileType);
    41      log.info(&quot;[Ingestion API] Upload successful: jobId={}&quot;, response.getJobId());
    42      return ResponseEntity.status(HttpStatus.CREATED).body(response);
    43    } catch (IllegalArgumentException e) {
    45      log.warn(&quot;[Ingestion API] Upload validation failed: {}&quot;, e.getMessage());
    46      throw e;
    47    } catch (IOException e) {
    48      log.error(&quot;[Ingestion API] File storage failed&quot;, e);
    49      throw new RuntimeException(&quot;Error storing file&quot;, e);
    50    }
    51    }
    52
    53    @GetMapping(&quot;/status/{jobId}&quot;)
    54    public ResponseEntity&lt;JobStatusResponse&gt; getJobStatus(@PathVariable String jobId) {
    55    log.debug(&quot;[Ingestion API] GET /status/{}&quot;, jobId);
    56    JobStatusResponse response = ingestionService.getJobStatus(jobId);
    57    return ResponseEntity.ok(response);
    58    }
    59
    60    @PatchMapping(&quot;/{jobId}/progress&quot;)
    61    public ResponseEntity&lt;Void&gt; updateProgress(
    61        @PathVariable String jobId,
    62        @Valid @RequestBody ProgressUpdateRequest request) {
    63
    64    log.debug(&quot;[Ingestion API] PATCH /{}/progress - delta={}&quot;, jobId, request.getProcessedRecordsDelta());
    65    ingestionService.updateProgress(jobId, request);
    66    return ResponseEntity.noContent().build();
    67    }
    68
    69    @PatchMapping(&quot;/{jobId}/status&quot;)
    70    public ResponseEntity&lt;Void&gt; updateStatus(
    71        @PathVariable String jobId,
    72        @Valid @RequestBody StatusUpdateRequest request) {
    73
    74    log.info(&quot;[Ingestion API] PATCH /{}/status - newStatus={}&quot;, jobId, request.getStatus());
    75    ingestionService.updateStatus(jobId, request);
    76    return ResponseEntity.noContent().build();
    77    }
    78
    79    @GetMapping(&quot;/health&quot;)
    80    public ResponseEntity&lt;String&gt; health() {
    81    return ResponseEntity.ok(&quot;Ingestion module healthy&quot;);
    82    }
    83  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.controller;</code></td>
<td>Controller package.</td>
</tr>
<tr>
<td>3-6</td>
<td>DTO imports</td>
<td>UploadResponse, JobStatusResponse, ProgressUpdateRequest, StatusUpdateRequest.</td>
</tr>
<tr>
<td>7</td>
<td><code>import com.mypolicy.pipeline.ingestion.service.IngestionService;</code></td>
<td>Service to delegate business logic.</td>
</tr>
<tr>
<td>8</td>
<td><code>import jakarta.validation.Valid;</code></td>
<td>@Valid triggers validation on request bodies.</td>
</tr>
<tr>
<td>9-10</td>
<td>Logger imports</td>
<td>For logging.</td>
</tr>
<tr>
<td>11-12</td>
<td>HttpStatus, ResponseEntity</td>
<td>For HTTP responses.</td>
</tr>
<tr>
<td>13</td>
<td><code>import org.springframework.web.bind.annotation.*;</code></td>
<td>@RestController, @PostMapping, @GetMapping, @PatchMapping, @RequestParam, @PathVariable, @RequestBody.</td>
</tr>
<tr>
<td>14</td>
<td><code>import org.springframework.web.multipart.MultipartFile;</code></td>
<td>Represents uploaded file.</td>
</tr>
<tr>
<td>16</td>
<td><code>import java.io.IOException;</code></td>
<td>For file I/O exceptions.</td>
</tr>
<tr>
<td>24</td>
<td><code>@RestController</code></td>
<td>Marks this as a REST controller; methods return data (not view names).</td>
</tr>
<tr>
<td>25</td>
<td><code>@RequestMapping("/api/v1/ingestion")</code></td>
<td>All endpoints start with /api/v1/ingestion.</td>
</tr>
<tr>
<td>26</td>
<td><code>@RequiredArgsConstructor</code></td>
<td>Lombok generates constructor for final fields (ingestionService).</td>
</tr>
<tr>
<td>28</td>
<td><code>private static final Logger log = ...</code></td>
<td>Logger instance for this class.</td>
</tr>
<tr>
<td>29</td>
<td><code>private final IngestionService ingestionService;</code></td>
<td>Injected service; final = set once in constructor.</td>
</tr>
<tr>
<td>31</td>
<td><code>@PostMapping("/upload")</code></td>
<td>Maps POST /api/v1/ingestion/upload to this method.</td>
</tr>
<tr>
<td>32-35</td>
<td>Method parameters</td>
<td>file (required), insurerId (required), uploadedBy (required), fileType (optional).</td>
</tr>
<tr>
<td>37</td>
<td><code>log.info(...)</code></td>
<td>Logs upload attempt.</td>
</tr>
<tr>
<td>39-50</td>
<td>try-catch</td>
<td>Calls service; returns 201; catches validation (rethrows) and IOException (wraps in RuntimeException).</td>
</tr>
<tr>
<td>53</td>
<td><code>@GetMapping("/status/{jobId}")</code></td>
<td>Maps GET /api/v1/ingestion/status/{jobId}.</td>
</tr>
<tr>
<td>54</td>
<td><code>@PathVariable String jobId</code></td>
<td>Reads jobId from URL path.</td>
</tr>
<tr>
<td>55-57</td>
<td>Log, service call, return</td>
<td>Returns 200 with JobStatusResponse.</td>
</tr>
<tr>
<td>60-67</td>
<td>updateProgress</td>
<td>PATCH /{jobId}/progress; validates body; returns 204.</td>
</tr>
<tr>
<td>69-77</td>
<td>updateStatus</td>
<td>PATCH /{jobId}/status; validates body; returns 204.</td>
</tr>
<tr>
<td>79-82</td>
<td>health</td>
<td>GET /health; returns 200 with "Ingestion module healthy".</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="9-publicingestioncontrollerjava">9. PublicIngestionController.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.ingestion.controller;
     2
     3  import com.mypolicy.ingestion.dto.JobStatusResponse;
     4  import com.mypolicy.ingestion.dto.UploadResponse;
     5  import com.mypolicy.ingestion.service.IngestionService;
     6  import org.slf4j.Logger;
     7  import org.slf4j.LoggerFactory;
     8  import org.springframework.http.HttpStatus;
     9  import org.springframework.http.ResponseEntity;
    10  import org.springframework.web.bind.annotation.*;
    11  import org.springframework.web.multipart.MultipartFile;
    12
    13  import java.io.IOException;
    14
    15  /**
    16  * Exposed customer-facing ingestion API.
    17  * Requires X-API-Key header (validated by ApiKeyAuthFilter).
    18  * Delegates to IngestionService - no business logic here.
    19  */
    20  @RestController
    21  @RequestMapping(&quot;/api/public/v1/ingestion&quot;)
    22  public class PublicIngestionController {
    23
    24    private static final Logger log = LoggerFactory.getLogger(PublicIngestionController.class);
    25    private final IngestionService ingestionService;
    26
    27    public PublicIngestionController(IngestionService ingestionService) {
    28      this.ingestionService = ingestionService;
    28    }
    29
    30    @PostMapping(&quot;/upload&quot;)
    31    public ResponseEntity&lt;UploadResponse&gt; uploadFile(
    32        @RequestParam(&quot;file&quot;) MultipartFile file,
    33        @RequestParam(&quot;insurerId&quot;) String insurerId,
    34        @RequestParam(&quot;uploadedBy&quot;) String uploadedBy,
    35        @RequestParam(value = &quot;fileType&quot;, required = false) String fileType) {
    36
    37    try {
    38      UploadResponse response = ingestionService.uploadFile(file, insurerId, uploadedBy, fileType);
    39      return ResponseEntity.status(HttpStatus.CREATED).body(response);
    40    } catch (IllegalArgumentException e) {
    41      log.warn(&quot;Upload validation failed: {}&quot;, e.getMessage());
    42      throw e;
    43    } catch (IOException e) {
    44      log.error(&quot;File storage failed&quot;, e);
    45      throw new RuntimeException(&quot;Error storing file&quot;, e);
    46    }
    47    }
    48
    49    @GetMapping(&quot;/status/{jobId}&quot;)
    50    public ResponseEntity&lt;JobStatusResponse&gt; getJobStatus(@PathVariable String jobId) {
    51    JobStatusResponse response = ingestionService.getJobStatus(jobId);
    52    return ResponseEntity.ok(response);
    53    }
    54  }
</code></pre>
<p><strong>Line-by-line explanation:</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.ingestion.controller;</code></td>
<td>Package (note: differs from pipeline.ingestion; may need alignment).</td>
</tr>
<tr>
<td>3-5</td>
<td>Imports</td>
<td>JobStatusResponse, UploadResponse, IngestionService.</td>
</tr>
<tr>
<td>20-21</td>
<td><code>@RestController</code> <code>@RequestMapping("/api/public/v1/ingestion")</code></td>
<td>Base path for public API.</td>
</tr>
<tr>
<td>27-28</td>
<td>Constructor</td>
<td>Injects IngestionService.</td>
</tr>
<tr>
<td>30-47</td>
<td>uploadFile</td>
<td>Same logic as IngestionController; expects X-API-Key in header (enforced by filter).</td>
</tr>
<tr>
<td>49-53</td>
<td>getJobStatus</td>
<td>Returns job status; also requires API key.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="10-ingestionservicejava">10. IngestionService.java</h2>
<p><strong>Full source code:</strong></p>
<pre><code class="language-java">     1  package com.mypolicy.pipeline.ingestion.service;
     2
     3  import com.mypolicy.pipeline.ingestion.dto.JobStatusResponse;
     4  import com.mypolicy.pipeline.ingestion.dto.ProgressUpdateRequest;
     5  import com.mypolicy.pipeline.ingestion.dto.StatusUpdateRequest;
     6  import com.mypolicy.pipeline.ingestion.dto.UploadResponse;
     7  import com.mypolicy.pipeline.ingestion.model.IngestionJob;
     8  import com.mypolicy.pipeline.ingestion.model.IngestionStatus;
     9  import com.mypolicy.pipeline.ingestion.repository.IngestionJobRepository;
    10  import com.mypolicy.ingestion.validation.InsurerSchemaValidator;
    11  import com.mypolicy.ingestion.validation.SchemaValidationResult;
    12  import lombok.RequiredArgsConstructor;
    13  import org.slf4j.Logger;
    14  import org.slf4j.LoggerFactory;
    15  import org.springframework.beans.factory.annotation.Value;
    16  import org.springframework.stereotype.Service;
    17  import org.springframework.web.multipart.MultipartFile;
    18
    19  import java.io.IOException;
    20  import java.io.InputStream;
    21  import java.nio.file.Files;
    22  import java.nio.file.Path;
    23  import java.nio.file.Paths;
    24  import java.time.LocalDateTime;
    25  import java.util.Arrays;
    26  import java.util.List;
    27  import java.util.UUID;
    28
    29  @Service
    30  @RequiredArgsConstructor
    31  public class IngestionService {
    32
    33    private static final Logger log = LoggerFactory.getLogger(IngestionService.class);
    34    private static final List&lt;String&gt; ALLOWED_EXTENSIONS = Arrays.asList(&quot;.xls&quot;, &quot;.xlsx&quot;, &quot;.csv&quot;);
    35    private static final long MAX_FILE_SIZE_BYTES = 50 * 1024 * 1024; // 50MB
    36
    37    private final IngestionJobRepository jobRepository;
    37    private final InsurerSchemaValidator schemaValidator;
    38
     39    @Value(&quot;${ingestion.storage.path:storage/ingestion}&quot;)
    40    private String storageBasePath;
    41
    42    @Value(&quot;${ingestion.schema.validate:true}&quot;)
    42    private boolean schemaValidationEnabled;
    43
    44    public UploadResponse uploadFile(MultipartFile file, String insurerId, String uploadedBy,
    45        String fileType) throws IOException {
    46
    47    log.info(&quot;[Ingestion] Starting file upload: insurerId={}, filename={}&quot;, insurerId, file.getOriginalFilename());
    48
    49    validateFile(file);
    50
    51    String resolvedFileType = resolveFileType(fileType, file.getOriginalFilename());
    52
    53    if (schemaValidationEnabled &amp;&amp; &quot;normal&quot;.equals(resolvedFileType)) {
    54      SchemaValidationResult schemaResult = schemaValidator.validate(file, insurerId);
    55      if (!schemaResult.isValid()) {
    56        throw new IllegalArgumentException(schemaResult.getErrorSummary());
    57      }
    58    }
    59
    60    String jobId = UUID.randomUUID().toString();
    61    String extension = getFileExtension(file.getOriginalFilename());
    62    Path storagePath = Paths.get(storageBasePath);
    63    if (!Files.exists(storagePath)) {
    64      Files.createDirectories(storagePath);
    65    }
    66
    67    Path filePath = storagePath.resolve(jobId + extension);
    68    try (InputStream inputStream = file.getInputStream()) {
    69      Files.copy(inputStream, filePath);
    70    }
    71
    73    log.info(&quot;[Ingestion] File uploaded: jobId={}, insurerId={}, fileType={}, path={}&quot;, jobId, insurerId,
    74        resolvedFileType, filePath.toAbsolutePath());
    75
    76    IngestionJob job = new IngestionJob(jobId, insurerId, filePath.toAbsolutePath().toString(),
    77        resolvedFileType, IngestionStatus.UPLOADED, 0, 0, uploadedBy, null,
    78        LocalDateTime.now(), LocalDateTime.now());
    79
    80    jobRepository.save(job);
    81
    82    log.info(&quot;[Ingestion] Job created: jobId={}, status=UPLOADED&quot;, jobId);
    83
    84    return new UploadResponse(jobId, IngestionStatus.UPLOADED);
    85    }
    86
    87    public JobStatusResponse getJobStatus(String jobId) {
    88    log.debug(&quot;[Ingestion] Fetching job status: jobId={}&quot;, jobId);
    89
    90    IngestionJob job = jobRepository.findById(jobId)
    91        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Job not found: &quot; + jobId));
    92
    93    return new JobStatusResponse(job.getJobId(), job.getStatus(), job.getProcessedRecords(),
    94        job.getTotalRecords(), job.getFilePath(), job.getInsurerId(), job.getFileType(),
    95        job.getCreatedAt(), job.getUpdatedAt());
    96    }
    97
    98    public IngestionJob getJob(String jobId) {
    99    return jobRepository.findById(jobId)
   100        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Job not found: &quot; + jobId));
   101    }
   102
   104    public void updateProgress(String jobId, ProgressUpdateRequest request) {
   105    if (request.getProcessedRecordsDelta() &lt;= 0) {
   106      throw new IllegalArgumentException(&quot;processedRecordsDelta must be positive&quot;);
   107    }
   108
   109    IngestionJob job = jobRepository.findById(jobId)
   110        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Job not found: &quot; + jobId));
   111
   112    if (job.getStatus() != IngestionStatus.PROCESSING) {
   113      throw new IllegalStateException(
   114          &quot;Cannot update progress: job must be in PROCESSING state, current=&quot; + job.getStatus());
   115    }
   116
   117    job.setProcessedRecords(job.getProcessedRecords() + request.getProcessedRecordsDelta());
   118    job.setUpdatedAt(LocalDateTime.now());
   119    jobRepository.save(job);
   120
   121    log.debug(&quot;[Ingestion] Progress updated: jobId={}, processed={}/{}&quot;, jobId, job.getProcessedRecords(),
   122        job.getTotalRecords());
   123    }
   124
   125    public void updateStatus(String jobId, StatusUpdateRequest request) {
   126    IngestionJob job = jobRepository.findById(jobId)
   127        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Job not found: &quot; + jobId));
   128
   129        IngestionStatus newStatus = request.getStatus();
    130    if (newStatus == null) {
    131      throw new IllegalArgumentException(&quot;status is required&quot;);
   131    }
   132
    133    IngestionStatus oldStatus = job.getStatus();
    134    validateStateTransition(oldStatus, newStatus);
    135
    136    job.setStatus(newStatus);
   136    job.setFailureReason(request.getFailureReason());
   137    job.setUpdatedAt(LocalDateTime.now());
   138    jobRepository.save(job);
   139
   140    log.info(&quot;[Ingestion] Status transition: jobId={}, {} -&gt; {}&quot;, jobId, oldStatus, newStatus);
   141    }
   142
   143    public void setTotalRecords(String jobId, int totalRecords) {
   144    IngestionJob job = jobRepository.findById(jobId)
   145        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Job not found: &quot; + jobId));
   146
   147    if (job.getStatus() != IngestionStatus.UPLOADED &amp;&amp; job.getStatus() != IngestionStatus.PROCESSING) {
   148      throw new IllegalStateException(&quot;Cannot set totalRecords in state: &quot; + job.getStatus());
   149    }
   150
   151    job.setTotalRecords(totalRecords);
   152    job.setUpdatedAt(LocalDateTime.now());
   153    jobRepository.save(job);
   154
   155    log.debug(&quot;[Ingestion] Total records set: jobId={}, total={}&quot;, jobId, totalRecords);
   156    }
   157
   158    private void validateFile(MultipartFile file) {
   159    if (file == null || file.isEmpty()) {
   160      throw new IllegalArgumentException(&quot;File is empty or missing&quot;);
   161    }
   162
   163    if (file.getSize() &gt; MAX_FILE_SIZE_BYTES) {
   164      throw new IllegalArgumentException(
   165          &quot;File size exceeds maximum allowed: &quot; + (MAX_FILE_SIZE_BYTES / 1024 / 1024) + &quot;MB&quot;);
   166    }
   167
   168    String originalName = file.getOriginalFilename();
   169    if (originalName == null || originalName.isBlank()) {
   170      throw new IllegalArgumentException(&quot;File name is missing&quot;);
   171    }
   172
   173    String ext = getFileExtension(originalName);
   174    if (ext == null || !ALLOWED_EXTENSIONS.contains(ext.toLowerCase())) {
   175      throw new IllegalArgumentException(
   176          &quot;Invalid file type. Allowed: &quot; + String.join(&quot;, &quot;, ALLOWED_EXTENSIONS));
   177    }
   178    }
   179
   180    private String getFileExtension(String filename) {
   181    if (filename == null) return null;
   182    int lastDot = filename.lastIndexOf('.');
   183    return lastDot &gt; 0 ? filename.substring(lastDot) : null;
   184    }
   185
   186    private String resolveFileType(String fileTypeParam, String filename) {
   187    if (fileTypeParam != null &amp;&amp; &quot;correction&quot;.equalsIgnoreCase(fileTypeParam.trim()))
   188      return &quot;correction&quot;;
   189    if (filename != null &amp;&amp; filename.toLowerCase().contains(&quot;_correction&quot;))
   190      return &quot;correction&quot;;
   191    return &quot;normal&quot;;
   192    }
   193
   194    private void validateStateTransition(IngestionStatus current, IngestionStatus next) {
   195    switch (current) {
   196      case UPLOADED:
   197        if (next != IngestionStatus.PROCESSING) {
   198          throw new IllegalStateException(&quot;Invalid transition: UPLOADED -&gt; &quot; + next);
   199        }
   200        break;
   201      case PROCESSING:
   202        if (next != IngestionStatus.COMPLETED &amp;&amp; next != IngestionStatus.FAILED) {
   203          throw new IllegalStateException(&quot;Invalid transition: PROCESSING -&gt; &quot; + next);
   204        }
   205        break;
   206      case COMPLETED:
   207      case FAILED:
   208        throw new IllegalStateException(&quot;No transitions allowed from terminal state: &quot; + current);
   209      default:
   210        throw new IllegalStateException(&quot;Unknown status: &quot; + current);
   211    }
   212    }
   213  }
</code></pre>
<p><strong>Line-by-line explanation (IngestionService):</strong></p>
<table>
<thead>
<tr>
<th>Line</th>
<th>Code</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>package com.mypolicy.pipeline.ingestion.service;</code></td>
<td>Service package.</td>
</tr>
<tr>
<td>3-6</td>
<td>DTO imports</td>
<td>JobStatusResponse, ProgressUpdateRequest, StatusUpdateRequest, UploadResponse.</td>
</tr>
<tr>
<td>7-9</td>
<td>Model/repo imports</td>
<td>IngestionJob, IngestionStatus, IngestionJobRepository.</td>
</tr>
<tr>
<td>10-11</td>
<td>InsurerSchemaValidator, SchemaValidationResult</td>
<td>Schema validation from ingestion-service module.</td>
</tr>
<tr>
<td>12</td>
<td><code>import lombok.RequiredArgsConstructor;</code></td>
<td>Lombok: generates constructor for final fields.</td>
</tr>
<tr>
<td>19-27</td>
<td>java.io, java.nio.file, java.time, java.util</td>
<td>I/O, paths, dates, Arrays, List, UUID.</td>
</tr>
<tr>
<td>29</td>
<td><code>@Service</code></td>
<td>Spring service bean.</td>
</tr>
<tr>
<td>30</td>
<td><code>@RequiredArgsConstructor</code></td>
<td>Constructor injection for jobRepository and schemaValidator.</td>
</tr>
<tr>
<td>33</td>
<td><code>private static final Logger log = ...</code></td>
<td>Logger.</td>
</tr>
<tr>
<td>34</td>
<td><code>ALLOWED_EXTENSIONS = Arrays.asList(".xls", ".xlsx", ".csv")</code></td>
<td>Allowed file extensions.</td>
</tr>
<tr>
<td>35</td>
<td><code>MAX_FILE_SIZE_BYTES = 50 * 1024 * 1024</code></td>
<td>50MB limit.</td>
</tr>
<tr>
<td>36-37</td>
<td><code>jobRepository</code>, <code>schemaValidator</code></td>
<td>Injected dependencies.</td>
</tr>
<tr>
<td>39-40</td>
<td><code>@Value("${ingestion.storage.path:storage/ingestion}")</code></td>
<td>Config property with default.</td>
</tr>
<tr>
<td>41-42</td>
<td><code>@Value("${ingestion.schema.validate:true}")</code></td>
<td>Enable/disable schema validation.</td>
</tr>
<tr>
<td>47</td>
<td><code>log.info(...)</code></td>
<td>Log upload start.</td>
</tr>
<tr>
<td>49</td>
<td><code>validateFile(file)</code></td>
<td>Step 1: validate file.</td>
</tr>
<tr>
<td>51</td>
<td><code>resolveFileType(...)</code></td>
<td>Step 2: determine normal vs correction.</td>
</tr>
<tr>
<td>53-58</td>
<td>Schema validation block</td>
<td>If enabled and normal: validate schema; throw if invalid.</td>
</tr>
<tr>
<td>60</td>
<td><code>UUID.randomUUID().toString()</code></td>
<td>Generate unique jobId.</td>
</tr>
<tr>
<td>61</td>
<td><code>getFileExtension(...)</code></td>
<td>Get .csv, .xls, or .xlsx.</td>
</tr>
<tr>
<td>62-65</td>
<td>Create storage dir</td>
<td>Paths.get, Files.exists, Files.createDirectories.</td>
</tr>
<tr>
<td>67</td>
<td><code>storagePath.resolve(jobId + extension)</code></td>
<td>Full path for saved file.</td>
</tr>
<tr>
<td>68-70</td>
<td>try-with-resources</td>
<td>Copy file input stream to disk; auto-close stream.</td>
</tr>
<tr>
<td>76-78</td>
<td><code>new IngestionJob(...)</code></td>
<td>Create job entity. Note: IngestionJob constructor may need fileType parameter.</td>
</tr>
<tr>
<td>80</td>
<td><code>jobRepository.save(job)</code></td>
<td>Persist to MongoDB.</td>
</tr>
<tr>
<td>84</td>
<td><code>return new UploadResponse(jobId, IngestionStatus.UPLOADED)</code></td>
<td>Return response.</td>
</tr>
<tr>
<td>90-91</td>
<td><code>findById(jobId).orElseThrow(...)</code></td>
<td>Load job or throw.</td>
</tr>
<tr>
<td>93-95</td>
<td><code>new JobStatusResponse(...)</code></td>
<td>Build response from job fields. job.getFileType() requires fileType on IngestionJob.</td>
</tr>
<tr>
<td>98-101</td>
<td><code>getJob</code></td>
<td>Returns raw IngestionJob for Processing.</td>
</tr>
<tr>
<td>105-106</td>
<td>Delta validation</td>
<td>processedRecordsDelta must be &gt; 0.</td>
</tr>
<tr>
<td>109-110</td>
<td>Load job</td>
<td>findById or throw.</td>
</tr>
<tr>
<td>112-115</td>
<td>Status check</td>
<td>Must be PROCESSING to update progress.</td>
</tr>
<tr>
<td>117-119</td>
<td>Update and save</td>
<td>Add delta to processedRecords, set updatedAt, save.</td>
</tr>
<tr>
<td>125-141</td>
<td>updateStatus</td>
<td>Load job, validate transition, set status and failureReason, save.</td>
</tr>
<tr>
<td>143-156</td>
<td>setTotalRecords</td>
<td>Only when UPLOADED or PROCESSING.</td>
</tr>
<tr>
<td>159-161</td>
<td>validateFile: null/empty</td>
<td>Reject if file missing or empty.</td>
</tr>
<tr>
<td>163-166</td>
<td>validateFile: size</td>
<td>Reject if &gt; 50MB.</td>
</tr>
<tr>
<td>168-171</td>
<td>validateFile: filename</td>
<td>Reject if no filename.</td>
</tr>
<tr>
<td>173-177</td>
<td>validateFile: extension</td>
<td>Reject if extension not in allowed list.</td>
</tr>
<tr>
<td>181-184</td>
<td>getFileExtension</td>
<td>lastIndexOf('.'); return substring or null.</td>
</tr>
<tr>
<td>186-192</td>
<td>resolveFileType</td>
<td>Param "correction" or filename "_correction" → correction; else normal.</td>
</tr>
<tr>
<td>194-212</td>
<td>validateStateTransition</td>
<td>UPLOADED→PROCESSING only; PROCESSING→COMPLETED/FAILED only; COMPLETED/FAILED→none.</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>End of Document</strong></p>
</body>
</html>